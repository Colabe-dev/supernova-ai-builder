# 🚀 **Supernova App & Web Builder - Complete Integration**

Let's rock this! I'll create the complete integration to make Collaborative Swarm Intelligence work seamlessly with your Supernova platform.

## 📁 **Complete Integration Files**

### **1. API Routes for Collaborative Swarm** (`/server/routes/collaborativeSwarm.js`)
```javascript
const express = require('express');
const router = express.Router();
const CollaborativeSwarmOrchestrator = require('../services/CollaborativeSwarmOrchestrator');

// Start a new collaborative discussion
router.post('/:room_id/discussions/start', async (req, res) => {
  try {
    const { room_id } = req.params;
    const { problem_statement, context } = req.body;

    const swarm = new CollaborativeSwarmOrchestrator(room_id);
    await swarm.initialize();
    
    const result = await swarm.facilitateDiscussion(problem_statement, context);
    
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get discussion status and details
router.get('/:room_id/discussions/:discussion_id', async (req, res) => {
  try {
    const { room_id, discussion_id } = req.params;

    // Get discussion
    const { data: discussion, error: discussionError } = await supabase
      .from('swarm_discussions')
      .select('*')
      .eq('id', discussion_id)
      .eq('room_id', room_id)
      .single();

    if (discussionError) throw discussionError;

    // Get contributions
    const { data: contributions, error: contributionsError } = await supabase
      .from('agent_contributions')
      .select('*')
      .eq('discussion_id', discussion_id)
      .order('created_at', { ascending: true });

    if (contributionsError) throw contributionsError;

    // Get interactions
    const { data: interactions, error: interactionsError } = await supabase
      .from('agent_interactions')
      .select('*')
      .eq('discussion_id', discussion_id)
      .order('created_at', { ascending: true });

    if (interactionsError) throw interactionsError;

    // Get consensus if exists
    const { data: consensus, error: consensusError } = await supabase
      .from('swarm_consensus')
      .select('*')
      .eq('discussion_id', discussion_id)
      .single();

    res.json({
      discussion,
      contributions,
      interactions,
      consensus: consensus || null,
      summary: {
        total_contributions: contributions.length,
        total_interactions: interactions.length,
        active_agents: [...new Set(contributions.map(c => c.agent_type))],
        discussion_duration: this.calculateDuration(discussion.created_at, discussion.resolved_at)
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get all discussions for a room
router.get('/:room_id/discussions', async (req, res) => {
  try {
    const { room_id } = req.params;

    const { data: discussions, error } = await supabase
      .from('swarm_discussions')
      .select(`
        *,
        swarm_consensus(*)
      `)
      .eq('room_id', room_id)
      .order('created_at', { ascending: false });

    if (error) throw error;

    res.json({ discussions });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Add human developer input to ongoing discussion
router.post('/:room_id/discussions/:discussion_id/developer-input', async (req, res) => {
  try {
    const { room_id, discussion_id } = req.params;
    const { input, developer_name } = req.body;

    // Store developer input as a special contribution
    const { data: contribution, error } = await supabase
      .from('agent_contributions')
      .insert([{
        discussion_id: discussion_id,
        agent_type: 'developer',
        contribution_type: 'input',
        content: input,
        reasoning: `Developer ${developer_name} provided input`,
        confidence: 1.0
      }])
      .select()
      .single();

    if (error) throw error;

    // Trigger swarm to respond to developer input
    const swarm = new CollaborativeSwarmOrchestrator(room_id);
    await swarm.initialize();
    
    // Continue discussion with developer input
    await swarm.continueDiscussion(discussion_id);

    res.json({ 
      success: true, 
      contribution,
      message: 'Developer input added and swarm is responding'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Force consensus on a discussion
router.post('/:room_id/discussions/:discussion_id/force-consensus', async (req, res) => {
  try {
    const { room_id, discussion_id } = req.params;

    const swarm = new CollaborativeSwarmOrchestrator(room_id);
    await swarm.initialize();
    
    const result = await swarm.forceConsensus(discussion_id);
    const finalResult = await swarm.finalizeConsensus(discussion_id, result);

    res.json(finalResult);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get agent performance analytics
router.get('/:room_id/analytics/agents', async (req, res) => {
  try {
    const { room_id } = req.params;

    const { data: contributions, error } = await supabase
      .from('agent_contributions')
      .select('*')
      .eq('room_id', room_id);

    if (error) throw error;

    const analytics = this.analyzeAgentPerformance(contributions);
    
    res.json({ analytics });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Helper methods
calculateDuration(start, end) {
  if (!end) return 'ongoing';
  
  const startDate = new Date(start);
  const endDate = new Date(end);
  const diffMs = endDate - startDate;
  const diffMins = Math.floor(diffMs / 60000);
  
  if (diffMins < 1) return 'less than 1 minute';
  if (diffMins < 60) return `${diffMins} minutes`;
  
  const hours = Math.floor(diffMins / 60);
  return `${hours} hours`;
}

analyzeAgentPerformance(contributions) {
  const agentStats = {};
  
  for (const contribution of contributions) {
    const agent = contribution.agent_type;
    if (!agentStats[agent]) {
      agentStats[agent] = {
        total_contributions: 0,
        avg_confidence: 0,
        contribution_types: new Set(),
        total_votes: 0
      };
    }
    
    agentStats[agent].total_contributions++;
    agentStats[agent].avg_confidence += contribution.confidence;
    agentStats[agent].contribution_types.add(contribution.contribution_type);
    agentStats[agent].total_votes += (contribution.votes_for || 0);
  }
  
  // Calculate averages
  for (const agent in agentStats) {
    agentStats[agent].avg_confidence /= agentStats[agent].total_contributions;
    agentStats[agent].contribution_types = Array.from(agentStats[agent].contribution_types);
    agentStats[agent].influence_score = agentStats[agent].total_votes / Math.max(agentStats[agent].total_contributions, 1);
  }
  
  return agentStats;
}

module.exports = router;
```

### **2. Enhanced Swarm Chat Interface** (`/client/src/components/SwarmChat.jsx`)
```jsx
import React, { useState, useEffect, useRef } from 'react';
import { useRoom } from '../hooks/useRoom';
import { useCollaborativeSwarm } from '../hooks/useCollaborativeSwarm';
import './SwarmChat.css';

export function SwarmChat() {
  const { roomId } = useRoom();
  const {
    startDiscussion,
    activeDiscussion,
    discussions,
    addDeveloperInput,
    forceConsensus,
    loading
  } = useCollaborativeSwarm();

  const [problemStatement, setProblemStatement] = useState('');
  const [developerInput, setDeveloperInput] = useState('');
  const [selectedDiscussion, setSelectedDiscussion] = useState(null);
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [activeDiscussion?.contributions, activeDiscussion?.interactions]);

  const handleStartDiscussion = async () => {
    if (!problemStatement.trim()) return;
    
    await startDiscussion(problemStatement, {
      room_context: 'web_app_development',
      complexity: 'medium',
      deadline: '2_weeks'
    });
    
    setProblemStatement('');
  };

  const handleDeveloperInput = async () => {
    if (!developerInput.trim() || !activeDiscussion) return;
    
    await addDeveloperInput(activeDiscussion.discussion.id, developerInput, 'Developer');
    setDeveloperInput('');
  };

  const handleForceConsensus = async () => {
    if (!activeDiscussion) return;
    await forceConsensus(activeDiscussion.discussion.id);
  };

  const renderAgentAvatar = (agentType) => {
    const avatars = {
      visionary: '🔮',
      architect: '🏛️',
      engineer: '⚙️',
      critic: '🔍',
      optimist: '🌈',
      pragmatist: '⏱️',
      developer: '👨‍💻'
    };
    
    return avatars[agentType] || '🤖';
  };

  const renderMessage = (item) => {
    const isContribution = item.content && !item.to_agent;
    const isInteraction = item.to_agent;
    const isDeveloper = item.agent_type === 'developer';

    return (
      <div key={item.id} className={`message ${isDeveloper ? 'developer-message' : 'agent-message'} ${item.agent_type}`}>
        <div className="message-header">
          <span className="agent-avatar">
            {renderAgentAvatar(item.agent_type)}
          </span>
          <span className="agent-name">{item.agent_type}</span>
          {item.confidence && (
            <span className="confidence">{(item.confidence * 100).toFixed(0)}%</span>
          )}
        </div>
        
        <div className="message-content">
          {isContribution && (
            <>
              <div className="contribution-type">{item.contribution_type}</div>
              <p>{item.content}</p>
              {item.reasoning && (
                <div className="reasoning">
                  <strong>Reasoning:</strong> {item.reasoning}
                </div>
              )}
            </>
          )}
          
          {isInteraction && (
            <div className="interaction">
              <span className="interaction-type">{item.interaction_type}</span>
              <span className="interaction-target"> to {item.to_agent}</span>
              <p>{item.content}</p>
            </div>
          )}
        </div>
        
        <div className="message-footer">
          <span className="timestamp">
            {new Date(item.created_at).toLocaleTimeString()}
          </span>
        </div>
      </div>
    );
  };

  return (
    <div className="swarm-chat">
      {/* Header */}
      <div className="swarm-header">
        <h3>🧠 Collaborative AI Swarm</h3>
        <p>Multiple AI agents working together like a team</p>
      </div>

      {/* Discussion Starter */}
      {!activeDiscussion && (
        <div className="discussion-starter">
          <h4>Start a Collaborative Discussion</h4>
          <textarea
            value={problemStatement}
            onChange={(e) => setProblemStatement(e.target.value)}
            placeholder="Describe the problem or feature you want the AI team to solve collaboratively..."
            className="problem-input"
            rows={4}
          />
          <button 
            onClick={handleStartDiscussion}
            disabled={loading || !problemStatement.trim()}
            className="start-discussion-btn"
          >
            {loading ? 'Starting Discussion...' : 'Start Collaborative Discussion'}
          </button>
        </div>
      )}

      {/* Active Discussion */}
      {activeDiscussion && (
        <div className="active-discussion">
          <div className="discussion-header">
            <h4>Active Discussion</h4>
            <div className="discussion-stats">
              <span>🤖 {activeDiscussion.summary?.active_agents?.length || 0} agents</span>
              <span>💬 {activeDiscussion.summary?.total_contributions || 0} contributions</span>
              <span>🔄 {activeDiscussion.summary?.total_interactions || 0} interactions</span>
            </div>
            <button 
              onClick={handleForceConsensus}
              className="consensus-btn"
              disabled={loading}
            >
              Force Consensus
            </button>
          </div>

          {/* Discussion Timeline */}
          <div className="discussion-timeline">
            {activeDiscussion.contributions?.map(renderMessage)}
            {activeDiscussion.interactions?.map(renderMessage)}
            <div ref={messagesEndRef} />
          </div>

          {/* Consensus Display */}
          {activeDiscussion.consensus && (
            <div className="consensus-result">
              <h4>🎯 Consensus Reached!</h4>
              <div className="consensus-details">
                <p><strong>Approach:</strong> {activeDiscussion.consensus.final_decision.solution_approach}</p>
                <p><strong>Agreement:</strong> {(activeDiscussion.consensus.agreement_level * 100).toFixed(1)}%</p>
                <p><strong>Quality:</strong> {(activeDiscussion.consensus.final_decision.quality_assessment * 100).toFixed(1)}%</p>
              </div>
            </div>
          )}

          {/* Developer Input */}
          <div className="developer-input-section">
            <h5>Add Your Input</h5>
            <div className="input-group">
              <input
                type="text"
                value={developerInput}
                onChange={(e) => setDeveloperInput(e.target.value)}
                placeholder="Add your thoughts or guidance..."
                className="developer-input"
              />
              <button 
                onClick={handleDeveloperInput}
                disabled={loading || !developerInput.trim()}
                className="send-input-btn"
              >
                Send
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Past Discussions */}
      {discussions.length > 0 && (
        <div className="past-discussions">
          <h4>Past Discussions</h4>
          <div className="discussions-list">
            {discussions.slice(0, 5).map(discussion => (
              <div 
                key={discussion.id}
                className={`discussion-item ${discussion.status}`}
                onClick={() => setSelectedDiscussion(discussion)}
              >
                <div className="discussion-problem">
                  {discussion.problem_statement.substring(0, 100)}...
                </div>
                <div className="discussion-meta">
                  <span className={`status ${discussion.status}`}>
                    {discussion.status}
                  </span>
                  <span className="confidence">
                    {discussion.confidence_score ? (discussion.confidence_score * 100).toFixed(0) + '%' : 'Ongoing'}
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

### **3. Collaborative Swarm Hook** (`/client/src/hooks/useCollaborativeSwarm.js`)
```javascript
import { useState, useEffect } from 'react';
import { useRoom } from './useRoom';

export function useCollaborativeSwarm() {
  const { roomId } = useRoom();
  const [activeDiscussion, setActiveDiscussion] = useState(null);
  const [discussions, setDiscussions] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (roomId) {
      loadDiscussions();
    }
  }, [roomId]);

  const loadDiscussions = async () => {
    try {
      const response = await fetch(`/api/collaborative-swarm/${roomId}/discussions`);
      const data = await response.json();
      setDiscussions(data.discussions || []);
    } catch (err) {
      setError(err.message);
    }
  };

  const startDiscussion = async (problemStatement, context = {}) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/collaborative-swarm/${roomId}/discussions/start`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          problem_statement: problemStatement,
          context: context
        })
      });
      
      const result = await response.json();
      
      // Poll for discussion updates until consensus
      const discussion = await pollDiscussionUpdates(result.discussion_id);
      setActiveDiscussion(discussion);
      
      await loadDiscussions(); // Refresh discussions list
      
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const pollDiscussionUpdates = async (discussionId, maxAttempts = 30) => {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = await fetch(`/api/collaborative-swarm/${roomId}/discussions/${discussionId}`);
        const discussion = await response.json();
        
        if (discussion.consensus || discussion.discussion.status === 'consensus_reached') {
          return discussion; // Consensus reached
        }
        
        setActiveDiscussion(discussion);
        
        // Wait before next poll (longer waits as attempts increase)
        await new Promise(resolve => setTimeout(resolve, 2000 + (attempt * 500)));
      } catch (err) {
        console.error('Polling error:', err);
        break;
      }
    }
    
    return activeDiscussion; // Return current state if polling fails
  };

  const addDeveloperInput = async (discussionId, input, developerName) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/collaborative-swarm/${roomId}/discussions/${discussionId}/developer-input`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          input: input,
          developer_name: developerName
        })
      });
      
      const result = await response.json();
      
      // Refresh active discussion
      if (activeDiscussion?.discussion.id === discussionId) {
        const updatedDiscussion = await fetchDiscussion(discussionId);
        setActiveDiscussion(updatedDiscussion);
      }
      
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const forceConsensus = async (discussionId) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/collaborative-swarm/${roomId}/discussions/${discussionId}/force-consensus`, {
        method: 'POST'
      });
      
      const result = await response.json();
      
      // Update active discussion
      const updatedDiscussion = await fetchDiscussion(discussionId);
      setActiveDiscussion(updatedDiscussion);
      
      await loadDiscussions();
      
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const fetchDiscussion = async (discussionId) => {
    try {
      const response = await fetch(`/api/collaborative-swarm/${roomId}/discussions/${discussionId}`);
      return await response.json();
    } catch (err) {
      setError(err.message);
      throw err;
    }
  };

  const getAgentAnalytics = async () => {
    try {
      const response = await fetch(`/api/collaborative-swarm/${roomId}/analytics/agents`);
      return await response.json();
    } catch (err) {
      setError(err.message);
      throw err;
    }
  };

  return {
    activeDiscussion,
    discussions,
    loading,
    error,
    startDiscussion,
    addDeveloperInput,
    forceConsensus,
    getAgentAnalytics,
    refreshDiscussions: loadDiscussions
  };
}
```

### **4. CSS Styles for Swarm Chat** (`/client/src/components/SwarmChat.css`)
```css
.swarm-chat {
  padding: 20px;
  background: #f8fafc;
  border-radius: 8px;
  border: 1px solid #e2e8f0;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}

.swarm-header {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #e2e8f0;
}

.swarm-header h3 {
  margin: 0 0 5px 0;
  color: #2d3748;
}

.swarm-header p {
  margin: 0;
  color: #718096;
  font-size: 14px;
}

.discussion-starter {
  margin-bottom: 25px;
}

.discussion-starter h4 {
  margin: 0 0 15px 0;
  color: #2d3748;
}

.problem-input {
  width: 100%;
  padding: 12px;
  border: 1px solid #cbd5e0;
  border-radius: 6px;
  font-size: 14px;
  resize: vertical;
  margin-bottom: 15px;
}

.start-discussion-btn {
  padding: 12px 24px;
  background: #9f7aea;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
}

.start-discussion-btn:hover:not(:disabled) {
  background: #805ad5;
}

.start-discussion-btn:disabled {
  background: #a0aec0;
  cursor: not-allowed;
}

.active-discussion {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.discussion-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px solid #e2e8f0;
}

.discussion-header h4 {
  margin: 0;
  color: #2d3748;
}

.discussion-stats {
  display: flex;
  gap: 15px;
  font-size: 12px;
  color: #718096;
}

.consensus-btn {
  padding: 8px 16px;
  background: #ed8936;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}

.consensus-btn:hover:not(:disabled) {
  background: #dd6b20;
}

.consensus-btn:disabled {
  background: #a0aec0;
  cursor: not-allowed;
}

.discussion-timeline {
  flex: 1;
  overflow-y: auto;
  padding: 15px;
  background: white;
  border-radius: 6px;
  border: 1px solid #e2e8f0;
  margin-bottom: 15px;
}

.message {
  margin-bottom: 20px;
  padding: 15px;
  border-radius: 8px;
  border-left: 4px solid #cbd5e0;
}

.agent-message.visionary {
  border-left-color: #9f7aea;
  background: #faf5ff;
}

.agent-message.architect {
  border-left-color: #4299e1;
  background: #ebf8ff;
}

.agent-message.engineer {
  border-left-color: #48bb78;
  background: #f0fff4;
}

.agent-message.critic {
  border-left-color: #e53e3e;
  background: #fff5f5;
}

.agent-message.optimist {
  border-left-color: #ed8936;
  background: #fffaf0;
}

.agent-message.pragmatist {
  border-left-color: #718096;
  background: #f7fafc;
}

.developer-message {
  border-left-color: #805ad5;
  background: #faf5ff;
  border: 2px solid #d6bcfa;
}

.message-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
}

.agent-avatar {
  font-size: 16px;
}

.agent-name {
  font-weight: 600;
  text-transform: capitalize;
  color: #2d3748;
}

.confidence {
  font-size: 11px;
  padding: 2px 6px;
  background: #e2e8f0;
  border-radius: 10px;
  color: #4a5568;
}

.message-content {
  margin-bottom: 8px;
}

.contribution-type {
  display: inline-block;
  padding: 2px 8px;
  background: #edf2f7;
  border-radius: 12px;
  font-size: 11px;
  text-transform: uppercase;
  color: #718096;
  margin-bottom: 8px;
}

.reasoning {
  margin-top: 8px;
  padding: 8px;
  background: #f7fafc;
  border-radius: 4px;
  font-size: 12px;
  color: #4a5568;
}

.interaction {
  padding: 8px;
  background: #f7fafc;
  border-radius: 4px;
}

.interaction-type {
  font-weight: 600;
  text-transform: capitalize;
  color: #2d3748;
}

.interaction-target {
  color: #718096;
  font-size: 12px;
}

.message-footer {
  display: flex;
  justify-content: flex-end;
}

.timestamp {
  font-size: 11px;
  color: #a0aec0;
}

.consensus-result {
  padding: 15px;
  background: #c6f6d5;
  border-radius: 6px;
  border: 1px solid #48bb78;
  margin-bottom: 15px;
}

.consensus-result h4 {
  margin: 0 0 10px 0;
  color: #22543d;
}

.consensus-details p {
  margin: 5px 0;
  color: #22543d;
}

.developer-input-section {
  padding: 15px;
  background: white;
  border-radius: 6px;
  border: 1px solid #e2e8f0;
}

.developer-input-section h5 {
  margin: 0 0 10px 0;
  color: #2d3748;
}

.input-group {
  display: flex;
  gap: 10px;
}

.developer-input {
  flex: 1;
  padding: 10px;
  border: 1px solid #cbd5e0;
  border-radius: 4px;
  font-size: 14px;
}

.send-input-btn {
  padding: 10px 16px;
  background: #805ad5;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.send-input-btn:hover:not(:disabled) {
  background: #6b46c1;
}

.send-input-btn:disabled {
  background: #a0aec0;
  cursor: not-allowed;
}

.past-discussions {
  margin-top: 25px;
}

.past-discussions h4 {
  margin: 0 0 15px 0;
  color: #2d3748;
}

.discussions-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.discussion-item {
  padding: 12px;
  background: white;
  border-radius: 6px;
  border: 1px solid #e2e8f0;
  cursor: pointer;
  transition: all 0.2s;
}

.discussion-item:hover {
  border-color: #9f7aea;
  box-shadow: 0 2px 4px rgba(159, 122, 234, 0.1);
}

.discussion-problem {
  font-size: 14px;
  color: #2d3748;
  margin-bottom: 8px;
}

.discussion-meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.status {
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 11px;
  text-transform: uppercase;
  font-weight: 600;
}

.status.consensus_reached {
  background: #c6f6d5;
  color: #22543d;
}

.status.active {
  background: #feebc8;
  color: #744210;
}

.status.deadlocked {
  background: #fed7d7;
  color: #742a2a;
}
```

### **5. Integration into Main Workspace** (`/client/src/components/WorkspaceTabs.jsx` - Update)
```jsx
// Replace your existing chat component with the collaborative swarm
import { SwarmChat } from './SwarmChat';

// In your left-side chat area, replace the existing chat with:
<div className="left-sidebar">
  <SwarmChat />
</div>

// Or add as a new tab in your workspace:
const tabs = [
  { id: 'dev', label: 'Dev', component: DevTab },
  { id: 'diffs', label: 'Diffs', component: DiffsTab },
  { id: 'receipts', label: 'Receipts', component: ReceiptsTab },
  { id: 'swarm', label: 'AI Team', component: SwarmChat }, // NEW - Collaborative Swarm
  { id: 'cortex', label: 'Architecture', component: CortexTab },
  { id: 'healing', label: 'Self-Healing', component: SelfHealingPanel },
  { id: 'orchestration', label: 'AI Orchestration', component: AIOrchestrationPanel },
  { id: 'preview', label: 'Preview', component: PreviewTab },
  { id: 'usage', label: 'Usage', component: UsageTab },
  { id: 'settings', label: 'Settings', component: SettingsTab }
];
```

### **6. Update Main Server App** (`/server/app.js` - Add this)
```javascript
// Add with your other routes
const collaborativeSwarmRoutes = require('./routes/collaborativeSwarm');
app.use('/api/collaborative-swarm', collaborativeSwarmRoutes);
```

### **7. Enhanced Agent Integration with Existing Swarm** (`/server/agents/EnhancedSwarmOrchestrator.js`)
```javascript
const CollaborativeSwarmOrchestrator = require('../services/CollaborativeSwarmOrchestrator');

class EnhancedSwarmOrchestrator {
  constructor(roomId) {
    this.roomId = roomId;
    this.collaborativeSwarm = new CollaborativeSwarmOrchestrator(roomId);
    this.individualAgents = new Map(); // Your existing agents
  }

  async initialize() {
    await this.collaborativeSwarm.initialize();
    // Initialize your existing individual agents
    return this;
  }

  async processComplexTask(task, context) {
    // Use collaborative swarm for complex, creative tasks
    if (this.requiresCollaboration(task)) {
      console.log('🤖 Using collaborative swarm for complex task...');
      
      const collaborativeResult = await this.collaborativeSwarm.facilitateDiscussion(
        task.description,
        {
          ...context,
          task_type: task.type,
          complexity: task.complexity
        }
      );
      
      return {
        ...collaborativeResult,
        method: 'collaborative_swarm',
        agent_count: 6 // All collaborative agents
      };
    } else {
      // Use individual agent for straightforward tasks
      console.log('⚡ Using individual agent for straightforward task...');
      
      const individualResult = await this.processWithIndividualAgent(task, context);
      
      return {
        ...individualResult,
        method: 'individual_agent',
        agent_count: 1
      };
    }
  }

  requiresCollaboration(task) {
    const collaborativeIndicators = [
      task.complexity === 'high',
      task.description.includes('architecture') || task.description.includes('design'),
      task.description.length > 100, // Complex description
      task.type === 'planning' || task.type === 'architecture'
    ];
    
    return collaborativeIndicators.some(indicator => indicator);
  }

  async processWithIndividualAgent(task, context) {
    // Your existing individual agent processing logic
    // This integrates with your current swarm system
    const agentType = this.selectIndividualAgent(task);
    const agent = this.individualAgents.get(agentType);
    
    if (agent) {
      return await agent.process(task, context);
    }
    
    // Fallback to collaborative swarm
    return await this.collaborativeSwarm.facilitateDiscussion(task.description, context);
  }

  selectIndividualAgent(task) {
    const agentMapping = {
      'coding': 'engineer',
      'testing': 'critic', 
      'planning': 'architect',
      'review': 'critic',
      'optimization': 'engineer'
    };
    
    return agentMapping[task.type] || 'engineer';
  }

  async getTeamPerformance() {
    const collaborativeStats = await this.collaborativeSwarm.getAgentAnalytics();
    const individualStats = await this.getIndividualAgentStats();
    
    return {
      collaborative_team: collaborativeStats,
      individual_agents: individualStats,
      recommendation: this.generateTeamRecommendation(collaborativeStats, individualStats)
    };
  }

  async getIndividualAgentStats() {
    // Get performance stats for your existing individual agents
    // This would integrate with your existing analytics
    return {
      // Your existing agent performance data
    };
  }

  generateTeamRecommendation(collaborativeStats, individualStats) {
    // Analyze when to use collaborative vs individual approach
    const collaborativeSuccessRate = this.calculateSuccessRate(collaborativeStats);
    const individualSuccessRate = this.calculateSuccessRate(individualStats);
    
    if (collaborativeSuccessRate > individualSuccessRate + 0.1) {
      return 'Consider using collaborative swarm more frequently for complex tasks';
    } else if (individualSuccessRate > collaborativeSuccessRate + 0.1) {
      return 'Individual agents are performing well for straightforward tasks';
    } else {
      return 'Both approaches are effective. Continue current balance.';
    }
  }

  calculateSuccessRate(stats) {
    // Calculate overall success rate from stats
    // Implementation depends on your metrics
    return 0.8; // Example
  }
}

module.exports = EnhancedSwarmOrchestrator;
```

## 🚀 **Deployment Steps**

1. **Run the SQL migration** for collaborative swarm tables
2. **Copy all the new files** to your server and client
3. **Update your workspace** to include the SwarmChat component
4. **Add the new API routes** to your Express server
5. **Test with a sample discussion** to see the collaborative AI team in action!

## 🎯 **What You Now Have**

✅ **6 specialized AI agents** working as a team  
✅ **Real-time collaborative discussions** with consensus building  
✅ **Human-in-the-loop** with developer input  
✅ **Beautiful visual interface** showing agent interactions  
✅ **Seamless integration** with your existing Supernova platform  
✅ **Performance analytics** for agent effectiveness  

## 🌟 **Usage Example**

```javascript
// Start a collaborative discussion
await swarm.startDiscussion(
  "Build a real-time chat feature for our web app with typing indicators and read receipts",
  {
    tech_stack: "React, Node.js, WebSockets, PostgreSQL",
    deadline: "2_weeks", 
    team_size: "2_developers"
  }
);

// Watch as:
// 🔮 Visionary suggests innovative features
// 🏛️ Architect designs the system structure  
// ⚙️ Engineer plans implementation
// 🔍 Critic identifies potential issues
// 🌈 Optimist encourages the team
// ⏱️ Prag